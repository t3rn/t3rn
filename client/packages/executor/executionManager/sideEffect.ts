import "@t3rn/types"
// @ts-ignore
import { T3rnTypesSideEffect } from '@polkadot/types/lookup';
import { TextDecoder } from "util"
const BN = require('bn.js')
import {SfxType, SfxStatus, SecurityLevel} from "@t3rn/sdk/dist/src/side-effects/types";
import {Sdk} from "@t3rn/sdk";
import {BehaviorSubject} from "rxjs";

// maps event names to SfxType enum;
export const EventMapper = ["Transfer", "MultiTransfer"]


export class SideEffect {
    step: number;
    status: SfxStatus;
    action: SfxType;
    target: string;
    hasInsurance: boolean;

    securityLevel: SecurityLevel
    iAmExecuting: boolean;
    relayer: any

    // SideEffect data
    id: string;
    xtxId: string;
    arguments: string[];
    insurance: number;
    reward: number;
    raw: T3rnTypesSideEffect;

    // TargetConfirmation
    inclusionData: any; // contains encoded payload, inclusionProof, and blockHash
    targetInclusionHeight: any;
    executor: string;

    // Risk/Reward Parameters:
    // this is the tx cost in the native currency of the target
    txCostNative: BehaviorSubject<number>;
    // cost of the native asset in USD. Used for tx cost calculation
    nativeAssetCostUsd: BehaviorSubject<number>;
    // current cost of the assets that are used for the sfx execution
    assetCostUsd: BehaviorSubject<number>;
    // profit that can be generated by executing this sfx
    maxProfitUsd: BehaviorSubject<number> = new BehaviorSubject<number>(0);

    constructor(sideEffect: T3rnTypesSideEffect, id: string, xtxId: string, sdk: Sdk) {
        if(this.knownTransactionInterface(sideEffect.encodedAction)) {
            this.raw = sideEffect;
            this.id = id;
            this.xtxId = xtxId
            this.arguments = sideEffect.encodedArgs.map(entry => entry.toString());
            this.target =  new TextDecoder().decode(sideEffect.target.toU8a())
            this.securityLevel = this.evalSecurityLevel(sdk.gateways[this.target].gatewayType)

        } else {
            console.log("SideEffect interface unknown!!")
        }
    }



    evalSecurityLevel(gatewayType: any): SecurityLevel {
        if (gatewayType.ProgrammableExternal === '0' || gatewayType.OnCircuit === '0') {
            return SecurityLevel.Escrow
        } else {
            return SecurityLevel.Optimistic
        }
    }

    // sets the step of the sideEffect in its execution
    setStep(step: number) {
        this.step = step
    }

    // setRiskRewardParameters(txCostNative: BehaviorSubject<number>, nativeAssetCostUsd: BehaviorSubject<number>, assetCostUsd: BehaviorSubject<number>) {
    setRiskRewardParameters(txCostNative: BehaviorSubject<number>) {
        this.txCostNative = txCostNative;
        // this.nativeAssetCostUsd = nativeAssetCostUsd;
        // this.assetCostUsd = assetCostUsd;

        this.txCostNative.subscribe((value: number) => {
            console.log("txCostNative", value)
            this.recomputeMaxProfit()
        })

        this.recomputeMaxProfit()
    }

    // computes the max profit that can be generated by executing this sfx and updates the maxProfitUsd subject
    recomputeMaxProfit() {
        console.log("recomputiong:", this.txCostNative.getValue())
        // const txCostUsd = this.txCostNative.getValue() * this.nativeAssetCostUsd.getValue()
        // const assetCost = this.assetCostUsd.getValue();
        // this.maxProfitUsd.next(this.reward - txCostUsd - assetCost);
        this.maxProfitUsd.next(this.txCostNative.getValue());
    }


    //
    // // ToDo remove once merged https://github.com/t3rn/t3rn/issues/432
    // checkForInsurance(argsLength: number, action: SfxType): boolean {
    //     switch(action) {
    //         case SfxType.Transfer: {
    //             if(argsLength === 4) {
    //                 this.status = Sfx.WaitingForInsurance;
    //                 return true;
    //             } else {
    //                 // if the sfx is dirty, its ready on creation.
    //                 this.status = SfxStatus.ReadyForExec;
    //                 this.iAmExecuting = true; // Dirty sfx can always be executed without bond
    //                 return false
    //             }
    //             break;
    //         }
    //     }
    // }

    updateStatus(status: SfxStatus) {
        this.status = status;
    }

    // return an array of arguments to execute on target.
    execute(): any[] | void {
        switch(this.action) {
            case SfxType.Transfer: {
                return this.getTransferArguments()
            }
        }
    }

    getTxOutput() {
        switch(this.action) {
            case SfxType.Transfer: {
                return parseInt(this.getTransferArguments()[1])
            }
        }
    }

    // updates status
    insuranceBonded(iAmExecuting: boolean) {
        this.status = SfxStatus.PendingExecution;
        this.iAmExecuting = iAmExecuting;
    }

    // sfx was successfully executed on target and has the inclusion proof data
    executedOnTarget(inclusionData: any, executor: any, targetInclusionHeight: any) {
        this.inclusionData = inclusionData;
        this.executor = executor;
        this.targetInclusionHeight = targetInclusionHeight;
        this.status = SfxStatus.ExecutedOnTarget;
    }

    // ensure we can deal with the sfx action and set SfxType
    private knownTransactionInterface(encodedAction: any): boolean {
        switch(encodedAction.toHuman()) {
            case "tran": {
                this.action = SfxType.Transfer
                return true
                break;
            }
            default: {
                return false
            }
        }
    }

    // returns the arguments
    private getTransferArguments(): string[] {
        return [
            // ToDo query prefix from xdns
            this.arguments[1],
            new BN(this.arguments[2].split("0x")[1], 16,"le").toString(),
        ]
    }
}